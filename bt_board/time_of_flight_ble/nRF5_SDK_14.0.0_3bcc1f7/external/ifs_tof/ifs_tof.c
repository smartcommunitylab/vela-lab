/*
*Copyright 2017 Fondazione Bruno Kessler
*
*Licensed under the Apache License, Version 2.0 (the "License");
*you may not use this file except in compliance with the License.
*You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
*Unless required by applicable law or agreed to in writing, software
*distributed under the License is distributed on an "AS IS" BASIS,
*WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*See the License for the specific language governing permissions and
*limitations under the License.
*
*
* author: Davide Giovanelli 2017 - davigiov88@gmail.com
*/


#include "ifs_tof.h"
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "sdk_config.h"
//#include "boards.h"
//#include "bsp.h"
//#include "bsp_btn_ble.h"
#include "nrf.h"
#include "ble_hci.h"
#include "nordic_common.h"
#include "nrf_gpio.h"
#include "ble_advdata.h"
#include "ble_srv_common.h"
//#include "nrf_ble_gatt.h"
#include "app_timer.h"
#include "app_error.h"
#include "ble_conn_params.h"

#include "nrf_gpiote.h"
#include "nrf_drv_ppi.h"
#include "nrf_drv_timer.h"
#include "nrf_drv_gpiote.h"
#include "nrf_egu.h"

#include "AHRS_lib.h"

#if SDK_VERSION == 13
#include "softdevice_handler.h"
#endif

#include "app_timer.h"

#include "nrf_log_default_backends.h"
#if DEBUG
#define  NRF_LOG_MODULE_NAME ifs_tof
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
NRF_LOG_MODULE_REGISTER();
#define PRINTF(...) NRF_LOG_DEBUG(__VA_ARGS__); /*\
                    NRF_LOG_PROCESS()*/
#else
#define PRINTF(...)
#endif

#define EGU_IRQn(id) 							CONCAT_5(SWI, id, _EGU, id, _IRQn)//SWI##i##_EGU##i##_IRQn // CONCAT_2( EGU_IRQ, IFS_TOF_EGU_INSTANCE )
#define GET_EGU_INSTANCE(id) 					(NRF_EGU_Type*) (NRF_EGU0_BASE + (((uint32_t) id) * (NRF_EGU1_BASE - NRF_EGU0_BASE)))
#define NRF_EGU 								GET_EGU_INSTANCE(IFS_TOF_EGU_INSTANCE)
#define GET_EGU_IRQHandler(id)					CONCAT_5(SWI, id, _EGU, id, _IRQHandler)
#define EGU_IRQHandler  						GET_EGU_IRQHandler( IFS_TOF_EGU_INSTANCE )
//#define GPIO_DEBUG_OUT_PIN_NUMBER 				NRF_GPIO_PIN_MAP(0,3)


const nrf_drv_timer_t TIMER = NRF_DRV_TIMER_INSTANCE(IFS_TOF_TIMER_INSTANCE);

static bool volatile m_ifs_tof_active = false;
static uint8_t m_number_of_registered_conn_handles = 0;

static volatile bool m_rx_ok = false, m_tx_ok = false, m_rssi_ok = false;
static volatile uint32_t m_timestamp = 0;
static volatile uint32_t m_rxaddress_evt_ticks_sample = 0, m_radio_freq_sample = 0;
static volatile uint32_t m_access_address_sample;
static int8_t m_rssi_sample;
static volatile uint16_t m_conn_handle_sample;
static volatile uint32_t m_ce_counter = 0; //this will count the overall amount of connection events
static ifs_tof_t * m_p_buff = NULL;
static uint8_t m_buff_size = 0;

void ifs_tof_on_single_sample_rdy(void);

//ifs_tof_t* get_instance_by_conn_handle(uint16_t target_conn_h){
//	if(m_p_buff == NULL){
//		return NULL;
//	}
//
//	return &m_p_buff[target_conn_h-1];
//}

ifs_tof_t* get_instance_by_conn_handle(uint16_t target_conn_h){
	if(m_p_buff == NULL){
		return NULL;
	}
	for(uint8_t i = 0; i < m_buff_size; i++){
		if(m_p_buff[i].conn_handle == target_conn_h){
			return &m_p_buff[i];
		}
	}
	//if it reach here it means that the connection handle isn't registered. Assign the first free position
	for(uint8_t i = 0; i < m_buff_size; i++){
		if(m_p_buff[i].conn_handle == BLE_CONN_HANDLE_INVALID){
			return &m_p_buff[i];
		}
	}
	return NULL;
}

#if SDK_VERSION == 13
void ifs_tof_on_ble_evt(const ble_evt_t * p_ble_evt){
#endif
#if SDK_VERSION == 14
void ifs_tof_on_ble_evt(const ble_evt_t * p_ble_evt, void * p_context){

	(void)p_context;
#endif
	uint32_t err_code;
	ble_gap_evt_t const * p_gap_evt = &p_ble_evt->evt.gap_evt;
	uint16_t m_conn_handle = p_gap_evt->conn_handle;

	switch (p_ble_evt->header.evt_id) {

	case BLE_GAP_EVT_CONNECTED:
		break;

	case BLE_GAP_EVT_DISCONNECTED:
		break;

#if defined(S140)
	case BLE_GAP_EVT_PHY_UPDATE: {

	}
		break;
#endif

	case BLE_GAP_EVT_RSSI_CHANGED:
		/*
		 * Note: there is no straight forward way for coupling the radio events generated by the radio with a peer (or a connection handle).
		 * Of course if only one connection is present the problem doesn't exist, but when multiple concurrent BLE connections are established
		 * we can measure the ToF but we cannot say which node the measure belongs to.
		 * Here we use the BLE_GAP_EVT_RSSI_CHANGED event to do so. For this we speculate that the BLE_GAP_EVT_RSSI_CHANGED always
		 * refers to the peer of the last ToF sample acquired. This is experimentally confirmed. Anyway when there are many peers
		 * connected with low connection interval values it is not clear if the behavior is reliable or not.
		 */
		//nrf_gpio_pin_toggle(GPIO_DEBUG_OUT_PIN_NUMBER);
		if (m_ifs_tof_active) {
			m_conn_handle_sample = m_conn_handle;
			int8_t api_rssi_sample;
			err_code = sd_ble_gap_rssi_get(m_conn_handle, &api_rssi_sample);
			if (err_code == NRF_SUCCESS && api_rssi_sample == m_rssi_sample) {//we already get the rssi value form the registers. Here just check the two values are the same, if not we cannot couple this event with the ToF value. This of course isn't very reliable, anyway after some test it turns out that it is enough (probably this check can be removed without any effect).
				m_rssi_ok = true;
				m_timestamp = app_timer_cnt_get();
				ifs_tof_on_single_sample_rdy();
			}

			m_rx_ok = false;
			m_tx_ok = false;
			m_rssi_ok = false;

		}
		nrf_drv_timer_pause(&TIMER);
		nrf_drv_timer_clear(&TIMER);
		break;

	default:
		break;
	}
}

#define RTT_THRESHOLD	600000000
void ifs_tof_on_single_sample_rdy(void) {
	ifs_tof_t* p_ctx = get_instance_by_conn_handle(m_conn_handle_sample); //here we actually associate the ToF sample with the proper connection handle obtained with BLE_GAP_EVT_RSSI_CHANGED event
	if (p_ctx == NULL) {
		return;
	}
	if (m_tx_ok && m_rx_ok && m_rssi_ok) {
		uint8_t data_rate_mbps = 1;
		uint32_t ifs_offset_ticks = (uint32_t) (T_IFS_us + PREAMBLE_LEGNTH_us + ACCESS_ADDRESS_LENGTH_bit / data_rate_mbps + RX_CHAIN_DELAY_1MPHY_us) * IFS_TIMER_TICK_FREQUENCY_MHZ;
		int32_t tof_tick = m_rxaddress_evt_ticks_sample - ifs_offset_ticks;
		if (tof_tick > RTT_THRESHOLD || tof_tick < -RTT_THRESHOLD) { //outlier rejection
			m_ce_counter = 0;
			return;
		}

		//get previous sample data, it is contained into p_ctx till it is overwritten
		uint32_t prev_timestamp = p_ctx->ifs_tof_sample.timestamp;
		uint32_t prev_frequency_reg = p_ctx->ifs_tof_sample.frequency_reg;
		int8_t prev_rssi = p_ctx->ifs_tof_sample.rssi;

		//prepare data for kalman update
		Sampled_Raw_Data iData;
		iData.freq[0] = (2400 + m_radio_freq_sample) * 1000000;
		iData.freq[1] = (2400 + prev_frequency_reg) * 1000000;
		iData.rssi[0] = m_rssi_sample;
		iData.rssi[1] = prev_rssi;
		iData.tof[0] = ((float) tof_tick) / ((float) (IFS_TIMER_TICK_FREQUENCY_MHZ * 1000000));
		float dT;

		if (prev_timestamp != 0) {
			dT = ((float) (m_timestamp - prev_timestamp)) / APP_TIMER_CLOCK_FREQ;
		} else {
			dT = DEFAULT_SAMPLING_RATE_S; //the ifs_tof module may store connection parameters and use the nominal connection interval in place of DEFAULT_SAMPLING_RATE_S
		}

#ifdef WORKAROUND_LOG
		NRF_LOG_DEBUG("New sample ToF = %.1f ns, RSSI = %d dBm, dT = %.3f ms\r\n",iData.tof[0]*1000000000, iData.rssi[0], dT*1000);
#endif
		KF_Update(&p_ctx->kf, &iData, dT);
		//store KF status and last valid data
		p_ctx->distance_buff.d[p_ctx->distance_buff.idx] = p_ctx->kf.kf_status.x_hat[0];
		p_ctx->distance_buff.v[p_ctx->distance_buff.idx] = p_ctx->kf.kf_status.x_hat[1];
		p_ctx->distance_buff.rssi[p_ctx->distance_buff.idx] = p_ctx->ifs_tof_sample.rssi;

		p_ctx->ifs_tof_sample.timestamp = m_timestamp;
//			p_ctx->ifs_tof_sample.connection_events_counter = m_ce_counter-1; //for some reason the connection event counter starts always from 2 and not 1....
		p_ctx->ifs_tof_sample.frequency_reg = m_radio_freq_sample;
		p_ctx->ifs_tof_sample.ifs_duration_ticks = m_rxaddress_evt_ticks_sample;
		p_ctx->ifs_tof_sample.rssi = m_rssi_sample;
		p_ctx->ifs_tof_sample.access_address = m_access_address_sample;

//		if (p_ctx->ifs_tof_sample.rssi > -45) {
//			int8_t rssi = p_ctx->ifs_tof_sample.rssi;
//			//update model to reset the offset
//			float d;
//			KF_Rssi_Data_Convert(&p_ctx->kf, rssi, &d);
//			float metersToCompensate = p_ctx->kf.kf_status.x_hat[0] / 2 - d;
//			KF_increase_RTT_offset_by_m(&(p_ctx->kf), metersToCompensate);
//
//			Sampled_Raw_Data initData; //NB: if sData is set to non-NULL the space allocated for initData isn't used
//			// reset kalman status
//			initData.rssi[0] = rssi;
//			initData.rssi[1] = rssi;
//			initData.tof[0] = p_ctx->kf.O_runtime; //to be precise here I should remove the offset due to d, however if rssi>45 d will be quite low and we can discard it
//			initData.freq[0] = 2400000000;
//			initData.freq[1] = 2400000000;
//			KF_Init(&p_ctx->kf, &initData); //this resets the status
//		}

		p_ctx->distance_buff.idx++;
	}
//	}else{
//		return;
//	}
	if (p_ctx->distance_buff.idx >= DISTANCE_REPORT_DOWNSAMPLE_RATIO) {
		if (p_ctx->evt_handler != NULL) {
			float avg_d=0, avg_v=0, avg_rssi;
			for(uint16_t i=0; i < DISTANCE_REPORT_DOWNSAMPLE_RATIO; i ++){
				avg_d+=p_ctx->distance_buff.d[i];
				avg_v+=p_ctx->distance_buff.v[i];
				avg_rssi+=p_ctx->distance_buff.rssi[i];
			}
			avg_d=avg_d/DISTANCE_REPORT_DOWNSAMPLE_RATIO;
			avg_v=avg_v/DISTANCE_REPORT_DOWNSAMPLE_RATIO;
			avg_rssi=avg_rssi/DISTANCE_REPORT_DOWNSAMPLE_RATIO;
			p_ctx->last_d_estimation=avg_d;
			p_ctx->last_v_estimation=avg_v;
			ifs_tof_evt_t evt;
			evt.evt_type = IFS_TOF_EVT_DISTANCE_READY;
			evt.p_ctx = p_ctx;
			p_ctx->evt_handler(&evt);	//call the application handler
//
//			if (avg_rssi > -40) {
//				int8_t rssi = avg_rssi;
//				//update model to reset the offset
//
//				Sampled_Raw_Data initData; //NB: if sData is set to non-NULL the space allocated for initData isn't used
//				// reset kalman status
//				initData.rssi[0] = rssi;
//				initData.rssi[1] = rssi;
//				initData.tof[0] = p_ctx->kf.O_runtime;
//				initData.freq[0] = 2400000000;
//				initData.freq[1] = 2400000000;
//				KF_Init(&p_ctx->kf, &initData); //this resets the status
//
//				float d;
//				KF_Rssi_Data_Convert(&p_ctx->kf, rssi, &d);
//				KF_increase_RTT_offset_by_m(&p_ctx->kf, avg_d-d);
//			}
//					else if(avg_d > 60){
//				//KF_increase_RTT_offset_by_m(&p_ctx->kf,avg_d);
//			}
		}
		p_ctx->distance_buff.idx = 0;
		m_ce_counter = 0;
	}
}

/**
 * @brief Handler for timer events.
 */
void timer_event_handler(nrf_timer_event_t event_type, void* p_context) {
	switch (event_type) {
	case NRF_TIMER_EVENT_COMPARE3: //if the timer reach the SUPERVISION_TIMEOUT_US there may be a corrupted packet, then the sample shall be discarded
		m_rx_ok = 0;
		m_tx_ok = 0;
		m_rssi_ok = false;
		break;
	default:
		//Do nothing.
		break;
	}
}


// The NRF_EGU peripheral is configured so that the interrupt handler is called when the radio generates the EVENTS_ADDRESS. This kind of event is identical when the address is
// transmitted or received, so we use the NRF_RADIO->STATE to understand if we are dealing with a TX_EVENTS_ADDRESS or a RX_EVENTS_ADDRESS.
void EGU_IRQHandler(void) {
	nrf_egu_event_t event = nrf_egu_event_triggered_get(NRF_EGU,IFS_TOF_EGU_CHANNEL);
	if(nrf_egu_event_check(NRF_EGU, event)){
		nrf_egu_event_clear(NRF_EGU, event);

		if (m_ifs_tof_active) {
			uint32_t radio_state = NRF_RADIO->STATE;
			if (radio_state == RADIO_STATE_TX) { //radio is in TX
				m_radio_freq_sample = NRF_RADIO->FREQUENCY;
				m_tx_ok = true;
				m_ce_counter++;
			}
			if (radio_state == RADIO_STATE_RX) { //radio is in RX
				m_rxaddress_evt_ticks_sample = TIMER.p_reg->CC[0];
				if (NRF_RADIO->EVENTS_RSSIEND) { //if the rssi sample is ready store it
					m_rssi_sample = -((int32_t) NRF_RADIO->RSSISAMPLE);
					//next part was an attempt to obtain the bd_addr of the peer without using BLE_GAP_EVT_RSSI_CHANGED, for now I had no success...
					//					m_rssi_ok = true;
					//					uint8_t rxaddresses = NRF_RADIO->RXADDRESSES;
					//					uint32_t base_address;
					//					uint32_t prefix0;
					//					if(rxaddresses == 1){
					//						base_address = NRF_RADIO->BASE0 & 0xFFFFFF00;
					//						prefix0 = NRF_RADIO->PREFIX0 & 0x000000FF;
					//						m_access_address_sample = base_address + prefix0;
					//					}else{
					//						rxaddresses = 0;
					//						base_address= 0;
					//						prefix0 = 0;
					//					}
				}
				m_rx_ok = true;
			}
		}
	}
}

ret_code_t ifs_tof_get_last_sample(ifs_tof_t * p_ctx, ifs_tof_sample_t* sample){ //this function permits to access all samples, not only those related to the registered connection handle
		//sample->conn_handle = m_conn_handle_sample;
		//sample->connection_events_counter = p_ctx->ifs_tof_sample.connection_events_counter;
		sample->frequency_reg = p_ctx->ifs_tof_sample.frequency_reg;
		sample->ifs_duration_ticks = p_ctx->ifs_tof_sample.ifs_duration_ticks;
		sample->rssi = p_ctx->ifs_tof_sample.rssi;
		sample->access_address = m_access_address_sample;
		return NRF_SUCCESS;
}

void ifs_tof_init_struct_buff(ifs_tof_t * p_ctx,uint16_t buff_size){
	for (uint8_t i = 0; i < buff_size; i++) { //reset all instance of m_ifs_tof and register the same handler for each node
		ifs_tof_init_struct(&p_ctx[i]);
	}
}

void ifs_tof_init_struct(ifs_tof_t * p_ctx){
	//p_ctx->sample_idx = 0;
	p_ctx->ce_counter = 0;
	p_ctx->evt_handler = NULL;
	p_ctx->conn_handle = BLE_CONN_HANDLE_INVALID;
	p_ctx->last_d_estimation=0;
    memset(&p_ctx->distance_buff, 0x00, sizeof(Distance_Data));

	KF_Init(&p_ctx->kf,NULL);
}

void ifs_tof_proximity_reset(void){

}

uint32_t ifs_tof_init(ifs_tof_t * p_buff, uint8_t max_buff_size){
//TODO: implement a deinit function for releasing the resources
	uint32_t address_evt_addr, end_evt_addr;
	uint32_t address_task_addr, end_task_addr;
	nrf_ppi_channel_t ppi_channel_radio_evt_address, ppi_channel_radio_evt_end;
	ret_code_t err_code;

	m_buff_size = max_buff_size;

	// Configure the timer that will measure the ToF. It also manage the supervision timeout.
	// (NB: this supervision timeout has nothing to do with the field supervision timeout of the BLE connection parameters)
	// in this case the supervision timeout is a safety timer to invalidate the measure if the NRF_RADIO->EVENTS_ADDRESS is not generated (because of a corrupted packet)
    nrf_drv_timer_config_t timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG;
    timer_cfg.bit_width = NRF_TIMER_BIT_WIDTH_32;
    timer_cfg.frequency = NRF_TIMER_FREQ_16MHz;
    timer_cfg.mode = NRF_TIMER_MODE_TIMER;
    timer_cfg.interrupt_priority = BLE_IFS_TOF_BLE_OBSERVER_PRIO;
    err_code = nrf_drv_timer_init(&TIMER, &timer_cfg, timer_event_handler);
    APP_ERROR_CHECK(err_code);
    TIMER.p_reg->EVENTS_COMPARE[3] = 0;
    uint32_t supervision_timeout_ticks = nrf_drv_timer_us_to_ticks(&TIMER, SUPERVISION_TIMEOUT_US);
    nrf_drv_timer_extended_compare(&TIMER, NRF_TIMER_CC_CHANNEL3, supervision_timeout_ticks, NRF_TIMER_SHORT_COMPARE3_STOP_MASK | NRF_TIMER_SHORT_COMPARE3_CLEAR_MASK , true);

    //Connect NRF_RADIO->EVENTS_END event to TIMER->TASKS_START so that the timer is automatically started with NRF_RADIO->EVENTS_END event
	err_code = nrf_drv_ppi_channel_alloc(&ppi_channel_radio_evt_end);
	APP_ERROR_CHECK(err_code);
	end_task_addr = (uint32_t) &(TIMER.p_reg->TASKS_START);
	end_evt_addr = (uint32_t) &(NRF_RADIO->EVENTS_END);
	err_code = nrf_drv_ppi_channel_assign(ppi_channel_radio_evt_end,end_evt_addr, end_task_addr);
	APP_ERROR_CHECK(err_code);

	//Connect NRF_RADIO->EVENTS_ADDRESS event to TIMER->TASKS_CAPTURE so that the counter value is automatically captured with NRF_RADIO->EVENTS_ADDRESS
	err_code = nrf_drv_ppi_channel_alloc(&ppi_channel_radio_evt_address);
	APP_ERROR_CHECK(err_code);
	address_evt_addr = (uint32_t)&(NRF_RADIO->EVENTS_ADDRESS);
	address_task_addr = (uint32_t) &(TIMER.p_reg->TASKS_CAPTURE[0]);
	err_code = nrf_drv_ppi_channel_assign(ppi_channel_radio_evt_address, address_evt_addr, address_task_addr);
	APP_ERROR_CHECK(err_code);

	//Connect (with a PPI fork) NRF_RADIO->EVENTS_ADDRESS event to and NRF_EGU channel so that we can read timer capture value using EGU_IRQHandler
	address_task_addr = (uint32_t)nrf_egu_task_trigger_address_get(NRF_EGU,IFS_TOF_EGU_CHANNEL);
	err_code = nrf_drv_ppi_channel_fork_assign(ppi_channel_radio_evt_address, address_task_addr);
	APP_ERROR_CHECK(err_code);

	//Enable NRF_EGU interrupt
#if SDK_VERSION == 13

    nrf_egu_int_enable(NRF_EGU, nrf_egu_int_get(NRF_EGU,IFS_TOF_EGU_CHANNEL));
    NVIC_ClearPendingIRQ(EGU_IRQn(IFS_TOF_EGU_INSTANCE));
    NVIC_SetPriority(EGU_IRQn(IFS_TOF_EGU_INSTANCE), BLE_IFS_TOF_BLE_OBSERVER_PRIO);
    NVIC_EnableIRQ(EGU_IRQn(IFS_TOF_EGU_INSTANCE));
#endif

#if SDK_VERSION == 14
	nrf_egu_event_clear(NRF_EGU, IFS_TOF_EGU_CHANNEL);
	nrf_egu_int_enable(NRF_EGU, nrf_egu_int_get(NRF_EGU,IFS_TOF_EGU_CHANNEL) );
    NVIC_ClearPendingIRQ(EGU_IRQn(IFS_TOF_EGU_INSTANCE));
    NVIC_SetPriority(EGU_IRQn(IFS_TOF_EGU_INSTANCE), BLE_IFS_TOF_BLE_OBSERVER_PRIO);
    NVIC_EnableIRQ(EGU_IRQn(IFS_TOF_EGU_INSTANCE));
#endif

	//Enable all PPI channels used.
	err_code = nrf_drv_ppi_channel_enable(ppi_channel_radio_evt_end);
	APP_ERROR_CHECK(err_code);
	err_code = nrf_drv_ppi_channel_enable(ppi_channel_radio_evt_address);
	APP_ERROR_CHECK(err_code);

	//Assign buffer pointer
	m_p_buff = p_buff;

#if SDK_VERSION == 14
	//Register the SoftDevice event observer to get ble stack events
	NRF_SDH_BLE_OBSERVER(m_ifs_tof_bel_obs, BLE_IFS_TOF_BLE_OBSERVER_PRIO, ifs_tof_on_ble_evt, NULL);
#endif

	return 0;//TODO: remove this dummy return and use real error codes
}

uint32_t ifs_tof_enable_module(void) {
    PRINTF("Enabling ifs tof module\n");
	m_ifs_tof_active = true;
	return 0;
}

uint32_t ifs_tof_disable_module(void){
    PRINTF("Disabling ifs tof module\n");
	m_ifs_tof_active = false;
	return 0;
}

uint32_t ifs_tof_register_conn_handle(const uint16_t conn_handle, ifs_tof_evt_handler_t evt_handler) { //this can be called multiple times (on different p_ctx objects) to register more conn_handles
//	ifs_tof_t * p_ctx = get_first_free_instance();
	ifs_tof_t * p_ctx = get_instance_by_conn_handle(conn_handle);
	if(p_ctx == NULL)
		return 1;

	//ifs_tof_init_struct(p_ctx); //this is mainly to reset kalman

	uint32_t ret = sd_ble_gap_rssi_start(conn_handle, 0, 0);
	p_ctx->evt_handler = evt_handler;
	p_ctx->conn_handle = conn_handle;

	m_number_of_registered_conn_handles++;

	return ret;
}

uint32_t ifs_tof_unregister_conn_handle(uint16_t connection_handle){
	ifs_tof_t * p_ctx = get_instance_by_conn_handle(connection_handle);
	if(p_ctx == NULL)
		return 1;

	sd_ble_gap_rssi_stop(p_ctx->conn_handle);
	m_number_of_registered_conn_handles--;
	if( m_number_of_registered_conn_handles == 0 ){
//		m_ifs_tof_active = false;					//this is for automatically disable ifs_tof module when the amount of tracked peers is zero. In the general case it is better to let the application to decide when the module have to be disabled.
	}
	p_ctx->conn_handle = BLE_CONN_HANDLE_INVALID;
	return 0;
}

uint16_t ifs_tof_get_number_of_registered_handles(void){
	return m_number_of_registered_conn_handles;
}


/** @}
 *  @endcond
 */
